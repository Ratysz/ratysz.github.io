initSidebarItems({"fn":[["check_update_time","This function will return true if the time since the last `update()` call has been equal to or greater to the update FPS indicated by the `target_fps`. It keeps track of fractional frames, so if you want 60 fps (16.67 ms/frame) and the game stutters so that there is 40 ms between `update()` calls, this will return `true` twice, and take the remaining 6.67 ms into account in the next frame."],["duration_to_f64","A convenience function to convert a Rust `Duration` type to a (less precise but more useful) f64."],["f64_to_duration","A convenience function to create a Rust `Duration` type from a (less precise but more useful) f64."],["get_average_delta","Gets the average time of a frame, averaged over the last 200 frames."],["get_delta","Get the time between the start of the last frame and the current one; in other words, the length of the last frame."],["get_fps","Gets the FPS of the game, averaged over the last 200 frames."],["get_remaining_update_time","Returns the fractional amount of a frame not consumed by  `check_update_time()`.  For example, if the desired update frame time is 40 ms (25 fps), and 45 ms have passed since the last frame, `check_update_time()` will return `true` and `get_remaining_update_time()` will return 5 ms -- the amount of time \"overflowing\" from one frame to the next."],["get_ticks","Gets the number of times the game has gone through its event loop."],["get_time_since_start","Returns the time since the game was initialized, as reported by the system clock."],["sleep","Pauses the current thread for the target duration. Just calls `std::thread::sleep()` so it's as accurate as that is (which is usually not very)."],["yield_now","Yields the current timeslice to the OS."]],"struct":[["TimeContext","A structure that contains our time-tracking state."]]});